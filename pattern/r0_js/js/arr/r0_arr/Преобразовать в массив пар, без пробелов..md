#split-filter-2for-if [[js]] [[js_arr]] 
#разделение_масс_чет-нечет #суммирование_паралельных_елмасс 
#проверка_типа_аргумента  #проверка_на_конец_строки_в_массиве
#filter 
```javascript
function splitString(str) {
  // Проверка на тип аргумента
  if (typeof str !== 'string') {
    throw new Error('Входной аргумент должен быть строкой.');
  }
// массив из знаков строки
  const r0 = str.split('');
  // массив из элементов с четными индексами r0
  // _ не используемый аргуммент
  const r1 = r0.filter((_, index) => index % 2 === 0);
  // массив из элементов с нечетными индексами r0
  const r2 = r0.filter((_, index) => index % 2 === 1);
  
// обьеденяем попарно ел.масс r1 и r2 
const mergedArray = r1.map((element, index) => element + 
// если В случае, если `r2[index]` равно `undefined` (т.е., если достигнут конец массива `r2` и текущий индекс `index` больше его длины), используется пустая строка `''`. Это делается с помощью оператора логического ИЛИ `||`. Если `r2[index]` равно `undefined`, возвращается пустая строка, иначе возвращается сам `r2[index]`.
//Если `r2[index]` равно `undefined`, будет добавлена пустая строка.
						   (r2[index] || '')
						);
// чтобы удалить элементы, которые имеют ложное (falsy) значение. пустые строки, `null`, `undefined`, `0` и `false`
  const filteredArray = mergedArray.filter(Boolean);

  return filteredArray;
}
```

```js
function splitString(str) { 
if (typeof str !== 'string') 
	throw new Error('Входной аргумент должен быть строкой.');

const r0 = str.split(''); const r1 = [], r2 = [];

for (let i = 0; i < r0.length; i += 2) 
{ 
	r1.push(r0[i]); 
	r2.push(r0[i + 1]); 
}

return r1.map((e, i) => e + (r2[i] || '')).filter(Boolean); }
```

```js
function splitString(str) {
// Проверка на тип аргумента
if (typeof str !== 'string') {
	throw new Error('Входной аргумент должен быть строкой.');
}
// создаем массив из знаков строки
  const r0 = str.split(''), r1 = [], r2 = [];
  let e;
// пересобираем в два массива чет и нечет
  for (let i = 0; i < r0.length; i += 2) {
    r1.push(r0[i]);
    r2.push(r0[i + 1]);
  }
// если количество знаков в строке, при остатке от делении на 2 оставляет 1
  if (r0.length % 2 === 1) {
    // суммируем массивы по парно
    // в условии заложено сокращение ложных срабатываний
    for (e = 0; e < (r0.length / 2) - 1; e++) 
    {
	    r1[e] += r2[e];
	}
// зачемто добавляем нижнее подчеркивание в последний ел масс? Не помню 
//	r1[e] += '_';
  } else {
// если количество знаков в строке, при остатке от делении на 2 оставляет не 1
    // суммируем массивы попарно
    for (let i = 0; i < r0.length; i++) 
    {
	    r1[i] += r2[i];
	}
  }
  // логическое НЕ, для удаления пустых ел.масс
  return r1.filter(x => !!x);
}
```