function func() {
  return this;
}

const outerObj = {
  value: 10,
  innerObj: {
    value: 20,
    method: func,
  },
};

const target = outerObj.innerObj;
const someVariable = target.method();

// я говорю вернет нихуя undefined
// The correct answer - innerObj.

// Если вы не знали, объекты JS — это сложный тип данных, и в отличие от примитивных типов, таких как число или термин, объекты присваиваются и копируются по ссылке. Другими словами, в переменной хранится не «значение объекта», а «ссылка» (адрес в памяти) этого значения. Следовательно, копирование такой переменной или передача ее в качестве аргумента функции копирует ссылку, а не сам объект. Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) выполняются с одним и тем же объектом.
// То есть в нашем случае targetта же innerObj, а не его копия. Просто теперь у нас есть 2 пути к его свойствам и методам — outerObj.innerObjи target
// thisравен объекту перед точкой, и в этом случае объект перед точкой target. Но, как мы поняли выше, targetи innerObjэто не просто два идентичных объекта или две копии — это один и тот же объект. Таким образом, у нас есть someVariable, targetи outerObj.innerObjвсе ссылки на один объект в памяти.
