// Подключаем пространство имен System, которое предоставляет основные классы и функциональность в C#
// using - директива, позволяющая использовать классы и методы из указанного пространства имен без указания полного имени        
using System;// System - пространство имен, содержащее базовые классы и функциональность .NET Framework
using System.Linq;// Linq - пространство имен, содержащее классы и методы для работы с запросами и операциями над данными (Language Integrated Query)

// public - модификатор доступа, позволяющий обращаться к классу из других частей программы
public class Program// Объявляем публичный класс Program
{
    public static void Main(string[] args)
    {
        // Объявляем метод Main, который является точкой входа в программу
        // static - модификатор, означающий, что метод Main является статическим и доступен без создания экземпляра класса
        // void - тип возвращаемого значения, указывающий, что метод Main не возвращает результат
        // Ввод пользовательских целых неотрицательных чисел для массива, разделенных пробелом
        Console.WriteLine("Введите целые неотрицательные числа для массива, разделяя их пробелом:");

        // Считываем введенную строку с целыми числами
        string input = Console.ReadLine();

        // Разделяем введенную строку на отдельные числа, используя пробел в качестве разделителя, и преобразуем их в целые числа
        string[] numStrings = input.Split(' ');
        int[] nums = numStrings.Select(int.Parse).ToArray();

// Находим - указывает на то, что следующая часть кода выполняет поиск
// третьего максимального элемента в массиве

int thirdMax = // Объявляем переменную thirdMax, которая будет хранить третий максимальный элемент

nums.Distinct() // Оставляем только уникальные элементы в массиве nums
// Distinct() - метод, который возвращает последовательность, содержащую только уникальные элементы

.OrderByDescending(x => x) // Сортируем элементы массива в порядке убывания
// OrderByDescending() - метод, который сортирует элементы последовательности в порядке убывания

.Skip(2) // Пропускаем первые два элемента после сортировки
// Skip() - метод, который пропускает указанное количество элементов

.FirstOrDefault(); // Возвращаем первый элемент после пропуска
// FirstOrDefault() - метод, который возвращает первый элемент последовательности или значение по умолчанию, если последовательность пуста

        // Находим третий максимальный элемент в массиве
//        int thirdMax = nums.Distinct().OrderByDescending(x => x).Skip(2).FirstOrDefault();

        // Находим максимальный элемент в массиве
        int max = nums.Max();

        // Проверяем, если третий максимальный элемент не равен 0, выводим его
        if (thirdMax != 0)
        {
            Console.WriteLine("Третий максимальный элемент: " + thirdMax);
        }
        // В противном случае выводим максимальный элемент
        else
        {
            Console.WriteLine("Максимальный элемент: " + max);
        }
    }
}












public class ThirdMaxElement {
    // Объявляем публичный класс ThirdMaxElement

    public int ThirdMax(int[] nums) {
        // Объявляем публичный метод ThirdMax, принимающий массив целых чисел nums и возвращающий целое число

        if(nums.Length == 0){
            throw new ArgumentException("nums should have at least one element");
        }
        // Проверяем, если массив nums пуст, выбрасываем исключение с сообщением об ошибке

        return _ThirdMaxRec(nums, 1, nums[0], null, null);
        // Возвращаем результат рекурсивного вызова приватного метода _ThirdMaxRec,
        // передавая ему массив nums, начальный индекс 1, первый максимальный элемент nums[0]
        // и значения второго и третьего максимального элементов, равные null
    }
    
    private int _ThirdMaxRec(int[] nums, int index, int fMax, int? sMax, int? tMax){
        // Объявляем приватный метод _ThirdMaxRec, принимающий массив nums, индекс, первый максимальный элемент fMax,
        // и значения второго и третьего максимальных элементов sMax и tMax (может быть null)

        // terminate
        if(index == nums.Length)
        {
            return tMax ?? fMax;
        }
        // Базовый случай: если индекс достигает длины массива, возвращаем третий максимальный элемент tMax,
        // если он определен, в противном случае возвращаем первый максимальный элемент fMax

        // handle duplicates
        if(nums[index] == fMax || nums[index] == sMax || nums[index] == tMax)
        {
            return _ThirdMaxRec(nums, index + 1, fMax, sMax, tMax);
        }
        // Обрабатываем случай, когда текущий элемент nums[index] является дубликатом одного из максимальных элементов.
        // Рекурсивно вызываем _ThirdMaxRec, переходя к следующему индексу, и передаем те же значения максимальных элементов

        // handle replacements
        if(nums[index] > fMax)
        {
            return _ThirdMaxRec(nums, index + 1, nums[index], fMax, sMax);
        }
        // Обрабатываем случай, когда текущий элемент nums[index] больше первого максимального элемента fMax.
        // Заменяем значения максимальных элементов и рекурсивно вызываем _ThirdMaxRec,
        // переходя к следующему индексу и передавая новые значения максимальных элементов

        if(sMax == null || nums[index] > sMax)
        {
            return _ThirdMaxRec(nums, index + 1, fMax, nums[index], sMax);
        }
        // Обрабатываем случай, когда текущий элемент nums[index] больше второго максимального элемента s
